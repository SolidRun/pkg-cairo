<?xml version='1.0' encoding='UTF-8'?> 
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY version SYSTEM "version.xml">
]>
<refentry id="cairo-cairo-t">
<refmeta>
<refentrytitle id="top_of_page">cairo_t</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>CAIRO Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>cairo_t</refname>
<refpurpose>The cairo drawing context</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv id="synopsis">
<title id="synopsis.title">Synopsis</title>

<synopsis>



typedef     <link linkend="cairo-t">cairo_t</link>;
enum        <link linkend="cairo-antialias-t">cairo_antialias_t</link>;
enum        <link linkend="cairo-fill-rule-t">cairo_fill_rule_t</link>;
enum        <link linkend="cairo-line-cap-t">cairo_line_cap_t</link>;
enum        <link linkend="cairo-line-join-t">cairo_line_join_t</link>;
enum        <link linkend="cairo-operator-t">cairo_operator_t</link>;

</synopsis>
</refsynopsisdiv>









<refsect1 id="desc">
<title id="desc.title">Description</title>

  <para>
    <link linkend="cairo-t"><type>cairo_t</type></link> is the main object used when drawing with cairo. To
    draw with cairo, you create a <link linkend="cairo-t"><type>cairo_t</type></link>, set the target surface,
    and drawing options for the <link linkend="cairo-t"><type>cairo_t</type></link>, create shapes with
    functions like <link linkend="cairo-move-to"><function>cairo_move_to()</function></link> and <link linkend="cairo-line-to"><function>cairo_line_to()</function></link>, and then
    draw shapes with <link linkend="cairo-stroke"><function>cairo_stroke()</function></link> or <link linkend="cairo-fill"><function>cairo_fill()</function></link>.
  </para>
  <para>
    <link linkend="cairo-t"><type>cairo_t</type></link><!-- -->'s can be pushed to a stack via <link linkend="cairo-save"><function>cairo_save()</function></link>.
    They may then safely be changed, without loosing the current state.
    Use <link linkend="cairo-restore"><function>cairo_restore()</function></link> to restore to the saved state.
  </para>
</refsect1>

<refsect1 id="details">
<title id="details.title">Details</title>
<refsect2>
<title><anchor id="cairo-t" role="typedef"/>cairo_t</title>
<indexterm><primary>cairo_t</primary></indexterm><programlisting>typedef struct _cairo cairo_t;
</programlisting>
<para>
A <link linkend="cairo-t"><type>cairo_t</type></link> contains the current state of the rendering device,
including coordinates of yet to be drawn shapes.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="cairo-antialias-t" role="enum"/>enum cairo_antialias_t</title>
<indexterm><primary>cairo_antialias_t</primary></indexterm><programlisting>typedef enum _cairo_antialias {
    CAIRO_ANTIALIAS_DEFAULT,
    CAIRO_ANTIALIAS_NONE,
    CAIRO_ANTIALIAS_GRAY,
    CAIRO_ANTIALIAS_SUBPIXEL
} cairo_antialias_t;
</programlisting>
<para>
Specifies the type of antialiasing to do when rendering text or shapes.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="CAIRO-ANTIALIAS-DEFAULT:CAPS" role="constant"/><literal>CAIRO_ANTIALIAS_DEFAULT</literal></term>
<listitem><simpara> Use the default antialiasing for
  the subsystem and target device
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="CAIRO-ANTIALIAS-NONE:CAPS" role="constant"/><literal>CAIRO_ANTIALIAS_NONE</literal></term>
<listitem><simpara> Use a bilevel alpha mask
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="CAIRO-ANTIALIAS-GRAY:CAPS" role="constant"/><literal>CAIRO_ANTIALIAS_GRAY</literal></term>
<listitem><simpara> Perform single-color antialiasing (using
 shades of gray for black text on a white background, for example).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="CAIRO-ANTIALIAS-SUBPIXEL:CAPS" role="constant"/><literal>CAIRO_ANTIALIAS_SUBPIXEL</literal></term>
<listitem><simpara> Perform antialiasing by taking
 advantage of the order of subpixel elements on devices
 such as LCD panels
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="cairo-fill-rule-t" role="enum"/>enum cairo_fill_rule_t</title>
<indexterm><primary>cairo_fill_rule_t</primary></indexterm><programlisting>typedef enum _cairo_fill_rule {
    CAIRO_FILL_RULE_WINDING,
    CAIRO_FILL_RULE_EVEN_ODD
} cairo_fill_rule_t;
</programlisting>
<para>
<link linkend="cairo-fill-rule-t"><type>cairo_fill_rule_t</type></link> is used to select how paths are filled. For both
fill rules, whether or not a point is included in the fill is
determined by taking a ray from that point to infinity and looking
at intersections with the path. The ray can be in any direction,
as long as it doesn't pass through the end point of a segment
or have a tricky intersection such as intersecting tangent to the path.
(Note that filling is not actually implemented in this way. This
is just a description of the rule that is applied.)</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="CAIRO-FILL-RULE-WINDING:CAPS" role="constant"/><literal>CAIRO_FILL_RULE_WINDING</literal></term>
<listitem><simpara> If the path crosses the ray from
left-to-right, counts +1. If the path crosses the ray
from right to left, counts -1. (Left and right are determined
from the perspective of looking along the ray from the starting
point.) If the total count is non-zero, the point will be filled.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="CAIRO-FILL-RULE-EVEN-ODD:CAPS" role="constant"/><literal>CAIRO_FILL_RULE_EVEN_ODD</literal></term>
<listitem><simpara> Counts the total number of
intersections, without regard to the orientation of the contour. If
the total number of intersections is odd, the point will be
filled.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="cairo-line-cap-t" role="enum"/>enum cairo_line_cap_t</title>
<indexterm><primary>cairo_line_cap_t</primary></indexterm><programlisting>typedef enum _cairo_line_cap {
    CAIRO_LINE_CAP_BUTT,
    CAIRO_LINE_CAP_ROUND,
    CAIRO_LINE_CAP_SQUARE
} cairo_line_cap_t;
</programlisting>
<para>
enumeration for style of line-endings</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="CAIRO-LINE-CAP-BUTT:CAPS" role="constant"/><literal>CAIRO_LINE_CAP_BUTT</literal></term>
<listitem><simpara> start(stop) the line exactly at the start(end) point
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="CAIRO-LINE-CAP-ROUND:CAPS" role="constant"/><literal>CAIRO_LINE_CAP_ROUND</literal></term>
<listitem><simpara> use a round ending, the center of the circle is the end point
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="CAIRO-LINE-CAP-SQUARE:CAPS" role="constant"/><literal>CAIRO_LINE_CAP_SQUARE</literal></term>
<listitem><simpara> use squared ending, the center of the square is the end point
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="cairo-line-join-t" role="enum"/>enum cairo_line_join_t</title>
<indexterm><primary>cairo_line_join_t</primary></indexterm><programlisting>typedef enum _cairo_line_join {
    CAIRO_LINE_JOIN_MITER,
    CAIRO_LINE_JOIN_ROUND,
    CAIRO_LINE_JOIN_BEVEL
} cairo_line_join_t;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="cairo-operator-t" role="enum"/>enum cairo_operator_t</title>
<indexterm><primary>cairo_operator_t</primary></indexterm><programlisting>typedef enum _cairo_operator {
    CAIRO_OPERATOR_CLEAR,

    CAIRO_OPERATOR_SOURCE,
    CAIRO_OPERATOR_OVER,
    CAIRO_OPERATOR_IN,
    CAIRO_OPERATOR_OUT,
    CAIRO_OPERATOR_ATOP,

    CAIRO_OPERATOR_DEST,
    CAIRO_OPERATOR_DEST_OVER,
    CAIRO_OPERATOR_DEST_IN,
    CAIRO_OPERATOR_DEST_OUT,
    CAIRO_OPERATOR_DEST_ATOP,

    CAIRO_OPERATOR_XOR,
    CAIRO_OPERATOR_ADD,
    CAIRO_OPERATOR_SATURATE
} cairo_operator_t;
</programlisting>
<para>

</para></refsect2>

</refsect1>




</refentry>
