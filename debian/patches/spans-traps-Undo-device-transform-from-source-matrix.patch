From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 3 Jun 2013 20:32:45 +0100
Subject: spans, traps: Undo device transform from source matrix for recording
 replays

As the replay of the recording surface applies the device_transform of
the matrix once again to all its operations, we end up with a repeated
transform through the source matrix of the recording surface. We need to
remove one of these, and the easiest way to do that appears to be to
undo the application to the source matrix.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
---
 src/cairo-spans-compositor.c | 13 +++++++++++--
 src/cairo-traps-compositor.c | 15 ++++++++++++---
 2 files changed, 23 insertions(+), 5 deletions(-)

diff --git a/src/cairo-spans-compositor.c b/src/cairo-spans-compositor.c
index 6eb9b42..1a46ea3 100644
--- a/src/cairo-spans-compositor.c
+++ b/src/cairo-spans-compositor.c
@@ -585,6 +585,8 @@ composite_aligned_boxes (const cairo_spans_compositor_t		*compositor,
     {
 	cairo_clip_t *recording_clip;
 	const cairo_pattern_t *source = &extents->source_pattern.base;
+	const cairo_matrix_t *m;
+	cairo_matrix_t matrix;
 
 	/* XXX could also do tiling repeat modes... */
 
@@ -600,10 +602,17 @@ composite_aligned_boxes (const cairo_spans_compositor_t		*compositor,
 	    dst->is_clear = TRUE;
 	}
 
+	m = &source->matrix;
+	if (_cairo_surface_has_device_transform (dst)) {
+	    cairo_matrix_multiply (&matrix,
+				   &source->matrix,
+				   &dst->device_transform);
+	    m = &matrix;
+	}
+
 	recording_clip = _cairo_clip_from_boxes (boxes);
 	status = _cairo_recording_surface_replay_with_clip (unwrap_source (source),
-							    &source->matrix,
-							    dst, recording_clip);
+							    m, dst, recording_clip);
 	_cairo_clip_destroy (recording_clip);
 
 	return status;
diff --git a/src/cairo-traps-compositor.c b/src/cairo-traps-compositor.c
index 988d23c..631e172 100644
--- a/src/cairo-traps-compositor.c
+++ b/src/cairo-traps-compositor.c
@@ -1206,7 +1206,9 @@ composite_aligned_boxes (const cairo_traps_compositor_t *compositor,
 					   &extents->source_sample_area))
     {
 	cairo_clip_t *recording_clip;
-	cairo_pattern_t *source = &extents->source_pattern.base;
+	const cairo_pattern_t *source = &extents->source_pattern.base;
+	const cairo_matrix_t *m;
+	cairo_matrix_t matrix;
 
 	/* XXX could also do tiling repeat modes... */
 
@@ -1225,10 +1227,17 @@ composite_aligned_boxes (const cairo_traps_compositor_t *compositor,
 		return status;
 	}
 
+	m = &source->matrix;
+	if (_cairo_surface_has_device_transform (dst)) {
+	    cairo_matrix_multiply (&matrix,
+				   &source->matrix,
+				   &dst->device_transform);
+	    m = &matrix;
+	}
+
 	recording_clip = _cairo_clip_from_boxes (boxes);
 	status = _cairo_recording_surface_replay_with_clip (recording_pattern_get_surface (source),
-							    &source->matrix,
-							    dst, recording_clip);
+							    m, dst, recording_clip);
 	_cairo_clip_destroy (recording_clip);
 
 	return status;
